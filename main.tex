\documentclass{utsignal}

\usepackage{amsmath}
\usepackage{wrapfig}
\usepackage{verbatim}
\usepackage{fancyvrb}
\usepackage{lscape}
\usepackage{rotating}
\usepackage{xepersian}
\usepackage{listings}
\usepackage{color}
\usepackage[utf8]{inputenc}

\title{تمرین کامپیوتری شماره‌ی ۱}
\course{سیگنال‌ها و سیستم‌ها}
\author{\href{mailto:hodabpour@gmail.com?subject=[SS\%20S98 A1]}{هدی برخوردارپور}، 
\href{mailto:ranjbar.ali@ut.ac.ir?subject=[SS\%20S98 A1]\%20}{علی رنجبر}}
\lecturer{امیرمسعود ربیعی}
\deadline{چهارشنبه ۲۲ اسفند ۱۳۹۷، ساعت ۲۳:۵۵}
\graphicspath{{./img/}}


\begin{document}
    \maketitle
    \section{مقدمه}
        در این تمرین کامپیوتری قصد داریم با نرم‌افزار ‌‌متلب\LTRfootnote{MATLAB}  و متمتیکا\LTRfootnote{Mathematica} آشنا شویم.
    \subsection{متلب}
 متلب، یک محیط نرم‌افزاری برای انجام محاسبات عددی و یک زبان برنامه‌نویسی نسل چهارم است که از ترکیب دو واژهٔ MATrix (ماتریس) و LABoratory (آزمایشگاه) ایجاد شده‌است.  این نام حاکی از رویکرد ماتریس محور برنامه است، که در آن حتی اعداد منفرد هم به عنوان ماتریس در نظر گرفته می‌شوند.
    \subsection{متمتیکا}
    متمتیکا، یک نرم‌افزار جبری بسیار رایج، که توسط شرکت ولفرم ریسرچ پدید آورده شده است و اکثر توابع نرم‌افزاری موردنیاز در ریاضی و علوم طبیعی را در اختیار استفاده‌کنندگان آن قرار می‌دهد.
    \subsection{مقایسه‌ی متلب و متمتیکا}
    \begin{itemize}
        \item جهت‌گیری متلب بیشتر برای کار با داده هاست (که در این بسیار خوب عمل می‌کند) اما با اینکه امکان محاسبات نمادین در‌ متلب وجود دارد، این امکان در متمتیکا بسیار آسان‌تر و کارآمدتر است. 
        \item متلب یک محیط برنامه‌نویسی در حوزه‌ی مهندسی است و چون محاسبات آن با استفاده از تقریب و تخمین‌های ریاضیست بنابراین در کارهای ریاضی کاربردی که اصل کار همان ساختن تقریب هاست ممکن است زیاد مناسب نباشد. 
    متمتیکا یک نرم‌افزار ریاضی است که هم در ریاضیات وهم در مهندسی کاربرد دارد. محاسبات نمادین و محض مثل حدگیری و مسایل جبر را به راحتی انجام داده و تمام مراحل حل را به کاربر نشان می‌دهد.
    
    \item مصورسازی و رسم نمودار در هر دو نرم افزار به خوبی انجام می‌شود.
    
    \item ساختن رابط کاربری برای نرم‌افزار در متمتیکا بسیار آسان‌تر از متلب است.
    \item مهمترین انتقادات از متلب به خاطر متن بازنبودن و گران بودن آن است که امکان اجرای کدهای نوشته‌شده در متلب را در هر محیطی محدود می‌کند.
    
	\end{itemize}
	\subsection{سیگنال‌ها در متلب}
	سیگنال‌های پیوسته-زمان  (به اختصار پیوسته) متناظر با هر نقطه‌ای از محور زمان یک مقداری دارند در حالی که سیگنال‌‌های گسسته-زمان (به اختصار گسسته) فقط در مقادیر صحیح از محور زمانی مقدار دارند. $x[n]$ یک سیگنال گسسته را نشان می‌دهد که $n$ فقط می‌تواند مقادیر صحیح اختیار کند.
	
	همان‌طور که می‌دانید ذخیره تمام مقادیر یک سیگنال پیوسته در طول یک بازه‌ی زمانی ناممکن است. پس چگونه سیگنال‌های پیوسته را پردازش کنیم؟ در آینده خواهید آموخت که چگونه یک سیگنال پیوسته را با نمونه‌برداری به سیگنال گسسته تبدیل می‌کنیم. (به کمک دستور \lstinline[language=Octave]{syms} می‌توان به شکل پیوسته کار کرد، که به هیچ وجه توصیه نمی‌شود و در صورت استفاده نمره‌ای تعلق نخواهد گرفت.)
	\section{کانولوشن گسسته-زمان}
	کانولوشن دو سیگنال گسسته $x[n]$ و $h[n]$ به صورت زیر تعریف می‌شود:
	$$y[n]=\sum_{m=-\infty}^{+\infty} x[m]h[n-m]$$
	تصویری از تعریف بالا را می‌توان به این صورت شرح داد: ابتدا دنباله  $h[m]$ نسبت به محور عمودی منعکس می‌شود و  $n$ نمونه به سمت چپ یا راست (با توجه به علامتت $n$) جابجا می‌شود. سپس دنباله  $h[n-m]$ در دنباله  $x[m]$ ضرب می‌شود و حاصل‌جمع ِدنباله حاصل را بدست می‌آوریم. این تصویر از ویژگی خطی بودن و تغییر ناپذیری زمان سیستم های گسسته-زمان بدست می‌آید. در این قسمت استفاده از تابع \lstinline[language=Octave]{conv} (در پایتون \lstinline[language=Python]{numpy.convolve}) را یاد می‌گیرید.
	\subsection{آموزش \lstinline[language=Octave]{conv}}
	اگر فرض کنیم سیگنال $x[n]$ فقط در بازه‌ای به طول $N_x$ و سیگنال $h[n]$ فقط در بازه‌ای به طول $N_h$ مقدار غیر صفر داشته باشند، آنگاه سیگنال $y[n]$ فقط در بازه‌ای بطول $N_x+N_h-1$ غیر صفر خواهد بود. بدین معنی که اگر  \lstinline[language=Octave]{x} برداری $N_x$ بعدی شامل مقادیر سیگنال  $x[n]$ و \lstinline[language=Octave]{h} برداری $N_h$ بعدی شامل مقادیر سیگنال $h[n]$ باشد، دستور 
	\begin{latin}
		\lstinputlisting[language=Octave]{convhx.m}
	\end{latin}
	\noindent به تعداد $N_x+N_h-1$ نمونه از $y[n]$ را در بردار \lstinline[language=Octave]{y} برمی‌گرداند.
	
	اگر دقت کرده باشبد، این دستور هیچ اطلاعی در مورد اندیس زمانی نمونه‌های سیگنال $y[n]$ (که در بردار \lstinline[language=Octave]{y} ذخیره شده است) برنمی‌گرداند که مورد انتظار نیز هست. چون هیچ ورودی از اندیس بردارهای \lstinline[language=Octave]{x} و \lstinline[language=Octave]{h} نمی‌گیرد. در این حالت باید خودتان اندیس‌‌های مناسبی بسازید. در ادامه با مثالی ساده نحوه‌ی ساخت این اندیس‌ها را یاد می‌گیرید.
	
	سیگنال زیر با طول محدود را در نظر بگیرید:
	$$
	x[n]=\begin{cases}
		1, & 0 \le n \le 5,\\
		0, & \text{otherwise}.
	\end{cases}
	$$
	ابتدا حاصل عبارت $y[n]=x[n]*x[n]$ را با تحلیل دستی حساب کنید.
	
	به کمک کد زیر می‌توانید کانولوشن را حساب کرده و آن را رسم کنید. دقت کنید که باید تابع \lstinline[language=Octave]{convIndices} را پیاده سازی کنید.
	\begin{latin}
		\lstinputlisting[language=Octave]{conv_example.m}
	\end{latin}
	
	
\end{document}